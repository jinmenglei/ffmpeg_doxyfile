\hypertarget{struct_a_v_h_w_accel}{}\doxysection{A\+V\+H\+W\+Accel Struct Reference}
\label{struct_a_v_h_w_accel}\index{AVHWAccel@{AVHWAccel}}


{\ttfamily \#include $<$avcodec.\+h$>$}



Collaboration diagram for A\+V\+H\+W\+Accel\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=175pt]{struct_a_v_h_w_accel__coll__graph}
\end{center}
\end{figure}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
const char $\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a9cc735be128cb62ff4cb594d3e3bdb92}{name}}
\item 
enum \mbox{\hyperlink{group__lavu__misc_ga9a84bba4713dfced21a1a56163be1f48}{A\+V\+Media\+Type}} \mbox{\hyperlink{struct_a_v_h_w_accel_af962ad3e15697454ba312d1254e5a423}{type}}
\item 
enum \mbox{\hyperlink{group__lavc__core_gaadca229ad2c20e060a14fec08a5cc7ce}{A\+V\+Codec\+ID}} \mbox{\hyperlink{struct_a_v_h_w_accel_a3c93d40193e9178eb7408295c6c2b2f2}{id}}
\item 
enum \mbox{\hyperlink{pixfmt_8h_a9a8e335cf3be472042bc9f0cf80cd4c5}{A\+V\+Pixel\+Format}} \mbox{\hyperlink{struct_a_v_h_w_accel_ac5692f044266af8c1c33b7ac549df338}{pix\+\_\+fmt}}
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_aa1da71a1cc27b60294023a893759e60a}{capabilities}}
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a0b800e0b878f67b81d17d269249b8a0f}{alloc\+\_\+frame}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{struct_a_v_frame}{A\+V\+Frame}} $\ast$\mbox{\hyperlink{cbs__vp9__syntax__template_8c_a78a801b08f3801b9059f0450b834984e}{frame}})
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a40b92f781dbaaecc9c82f636b790629b}{start\+\_\+frame}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_abdc909c18b35ae3a537a56e93b1cc8ee}{decode\+\_\+params}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_af962ad3e15697454ba312d1254e5a423}{type}}, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_ab1effeed94fc20e372a60fec7c4d741b}{decode\+\_\+slice}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_ae7f4bdfa848f4c38bb6d9d059c11a297}{end\+\_\+frame}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_aecd7bfd22ce294f1ae5073164bb90d65}{frame\+\_\+priv\+\_\+data\+\_\+size}}
\item 
\mbox{\hyperlink{rematrix__template_8c_a4dfdfbb7b69470f1152e022432ee2d45}{void}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a78303ba4f7601306141d5f8bfe05d00e}{decode\+\_\+mb}} )(struct \mbox{\hyperlink{struct_mpeg_enc_context}{Mpeg\+Enc\+Context}} $\ast$\mbox{\hyperlink{sw__rgb_8c_a517a4433fe5466cc6af1c80c538b0881}{s}})
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a8acb795f85f9852a98663e0944797d24}{init}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_a19115ab5af7bf9e638889ffee0b4e232}{uninit}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_a0094df5ea13d644ebcba1237d45055be}{priv\+\_\+data\+\_\+size}}
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_ac86c35478948dd4c3ee5619db982ee0d}{caps\+\_\+internal}}
\item 
\mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ \mbox{\hyperlink{struct_a_v_h_w_accel_ab532881fdb5e79698b79840d509978bc}{frame\+\_\+params}} )(\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}} $\ast$hw\+\_\+frames\+\_\+ctx)
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}


Definition at line 2410 of file avcodec.\+h.



\doxysubsection{Member Data Documentation}
\mbox{\Hypertarget{struct_a_v_h_w_accel_a0b800e0b878f67b81d17d269249b8a0f}\label{struct_a_v_h_w_accel_a0b800e0b878f67b81d17d269249b8a0f}} 
\index{AVHWAccel@{AVHWAccel}!alloc\_frame@{alloc\_frame}}
\index{alloc\_frame@{alloc\_frame}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{alloc\_frame}{alloc\_frame}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::alloc\+\_\+frame) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{struct_a_v_frame}{A\+V\+Frame}} $\ast$\mbox{\hyperlink{cbs__vp9__syntax__template_8c_a78a801b08f3801b9059f0450b834984e}{frame}})}

Allocate a custom buffer 

Definition at line 2456 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_aa1da71a1cc27b60294023a893759e60a}\label{struct_a_v_h_w_accel_aa1da71a1cc27b60294023a893759e60a}} 
\index{AVHWAccel@{AVHWAccel}!capabilities@{capabilities}}
\index{capabilities@{capabilities}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{capabilities}{capabilities}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} A\+V\+H\+W\+Accel\+::capabilities}

Hardware accelerated codec capabilities. see A\+V\+\_\+\+H\+W\+A\+C\+C\+E\+L\+\_\+\+C\+O\+D\+E\+C\+\_\+\+C\+A\+P\+\_\+$\ast$ 

Definition at line 2443 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_ac86c35478948dd4c3ee5619db982ee0d}\label{struct_a_v_h_w_accel_ac86c35478948dd4c3ee5619db982ee0d}} 
\index{AVHWAccel@{AVHWAccel}!caps\_internal@{caps\_internal}}
\index{caps\_internal@{caps\_internal}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{caps\_internal}{caps\_internal}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} A\+V\+H\+W\+Accel\+::caps\+\_\+internal}

Internal hwaccel capabilities. 

Definition at line 2559 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a78303ba4f7601306141d5f8bfe05d00e}\label{struct_a_v_h_w_accel_a78303ba4f7601306141d5f8bfe05d00e}} 
\index{AVHWAccel@{AVHWAccel}!decode\_mb@{decode\_mb}}
\index{decode\_mb@{decode\_mb}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{decode\_mb}{decode\_mb}}
{\footnotesize\ttfamily \mbox{\hyperlink{rematrix__template_8c_a4dfdfbb7b69470f1152e022432ee2d45}{void}}($\ast$ A\+V\+H\+W\+Accel\+::decode\+\_\+mb) (struct \mbox{\hyperlink{struct_mpeg_enc_context}{Mpeg\+Enc\+Context}} $\ast$\mbox{\hyperlink{sw__rgb_8c_a517a4433fe5466cc6af1c80c538b0881}{s}})}

Called for every Macroblock in a slice.

Xv\+MC uses it to replace the \mbox{\hyperlink{mpegvideo_8c_a8f3e2740f33856036d181a6e5d2128a3}{ff\+\_\+mpv\+\_\+reconstruct\+\_\+mb()}}. Instead of decoding to raw picture, MB parameters are stored in an array provided by the video driver.


\begin{DoxyParams}{Parameters}
{\em s} & the mpeg context \\
\hline
\end{DoxyParams}


Definition at line 2531 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_abdc909c18b35ae3a537a56e93b1cc8ee}\label{struct_a_v_h_w_accel_abdc909c18b35ae3a537a56e93b1cc8ee}} 
\index{AVHWAccel@{AVHWAccel}!decode\_params@{decode\_params}}
\index{decode\_params@{decode\_params}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{decode\_params}{decode\_params}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::decode\+\_\+params) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} \mbox{\hyperlink{struct_a_v_h_w_accel_af962ad3e15697454ba312d1254e5a423}{type}}, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)}

Callback for parameter data (S\+P\+S/\+P\+P\+S/\+V\+PS etc).

Useful for hardware decoders which keep persistent state about the video parameters, and need to receive any changes to update that state.


\begin{DoxyParams}{Parameters}
{\em avctx} & the codec context \\
\hline
{\em type} & the nal unit type \\
\hline
{\em buf} & the nal unit data buffer \\
\hline
{\em buf\+\_\+size} & the size of the nal unit in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero if successful, a negative value otherwise 
\end{DoxyReturn}


Definition at line 2486 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_ab1effeed94fc20e372a60fec7c4d741b}\label{struct_a_v_h_w_accel_ab1effeed94fc20e372a60fec7c4d741b}} 
\index{AVHWAccel@{AVHWAccel}!decode\_slice@{decode\_slice}}
\index{decode\_slice@{decode\_slice}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{decode\_slice}{decode\_slice}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::decode\+\_\+slice) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)}

Callback for each slice.

Meaningful slice information (codec specific) is guaranteed to be parsed at this point. This function is mandatory. The only exception is Xv\+MC, that works on MB level.


\begin{DoxyParams}{Parameters}
{\em avctx} & the codec context \\
\hline
{\em buf} & the slice data buffer base \\
\hline
{\em buf\+\_\+size} & the size of the slice in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero if successful, a negative value otherwise 
\end{DoxyReturn}


Definition at line 2500 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_ae7f4bdfa848f4c38bb6d9d059c11a297}\label{struct_a_v_h_w_accel_ae7f4bdfa848f4c38bb6d9d059c11a297}} 
\index{AVHWAccel@{AVHWAccel}!end\_frame@{end\_frame}}
\index{end\_frame@{end\_frame}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{end\_frame}{end\_frame}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::end\+\_\+frame) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)}

Called at the end of each frame or field picture.

The whole picture is parsed at this point and can now be sent to the hardware accelerator. This function is mandatory.


\begin{DoxyParams}{Parameters}
{\em avctx} & the codec context \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero if successful, a negative value otherwise 
\end{DoxyReturn}


Definition at line 2511 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_ab532881fdb5e79698b79840d509978bc}\label{struct_a_v_h_w_accel_ab532881fdb5e79698b79840d509978bc}} 
\index{AVHWAccel@{AVHWAccel}!frame\_params@{frame\_params}}
\index{frame\_params@{frame\_params}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{frame\_params}{frame\_params}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::frame\+\_\+params) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, \mbox{\hyperlink{struct_a_v_buffer_ref}{A\+V\+Buffer\+Ref}} $\ast$hw\+\_\+frames\+\_\+ctx)}

Fill the given hw\+\_\+frames context with current codec parameters. Called from get\+\_\+format. Refer to \mbox{\hyperlink{group__lavc__decoding_ga7fc990105405e7958f8051cee81bee6b}{avcodec\+\_\+get\+\_\+hw\+\_\+frames\+\_\+parameters()}} for details.

This C\+AN be called before \mbox{\hyperlink{struct_a_v_h_w_accel_a8acb795f85f9852a98663e0944797d24}{A\+V\+H\+W\+Accel.\+init}} is called, and you must assume that avctx-\/$>$hwaccel\+\_\+priv\+\_\+data is invalid. 

Definition at line 2569 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_aecd7bfd22ce294f1ae5073164bb90d65}\label{struct_a_v_h_w_accel_aecd7bfd22ce294f1ae5073164bb90d65}} 
\index{AVHWAccel@{AVHWAccel}!frame\_priv\_data\_size@{frame\_priv\_data\_size}}
\index{frame\_priv\_data\_size@{frame\_priv\_data\_size}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{frame\_priv\_data\_size}{frame\_priv\_data\_size}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} A\+V\+H\+W\+Accel\+::frame\+\_\+priv\+\_\+data\+\_\+size}

Size of per-\/frame hardware accelerator private data.

Private data is allocated with \mbox{\hyperlink{group__lavu__mem__funcs_gaf143ecab33a3868b57345466c39de7c1}{av\+\_\+mallocz()}} before A\+V\+Codec\+Context.\+get\+\_\+buffer() and deallocated after A\+V\+Codec\+Context.\+release\+\_\+buffer(). 

Definition at line 2520 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a3c93d40193e9178eb7408295c6c2b2f2}\label{struct_a_v_h_w_accel_a3c93d40193e9178eb7408295c6c2b2f2}} 
\index{AVHWAccel@{AVHWAccel}!id@{id}}
\index{id@{id}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{id}{id}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lavc__core_gaadca229ad2c20e060a14fec08a5cc7ce}{A\+V\+Codec\+ID}} A\+V\+H\+W\+Accel\+::id}

Codec implemented by the hardware accelerator.

See A\+V\+\_\+\+C\+O\+D\+E\+C\+\_\+\+I\+D\+\_\+xxx 

Definition at line 2416 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a8acb795f85f9852a98663e0944797d24}\label{struct_a_v_h_w_accel_a8acb795f85f9852a98663e0944797d24}} 
\index{AVHWAccel@{AVHWAccel}!init@{init}}
\index{init@{init}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{init}{init}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::init) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)}

Initialize the hwaccel private data.

This will be called from \mbox{\hyperlink{decode_8c_a8a7eadb05d8ea6f849a146035377ad1f}{ff\+\_\+get\+\_\+format()}}, after hwaccel and hwaccel\+\_\+context are set and the hwaccel private data in \mbox{\hyperlink{struct_a_v_codec_internal}{A\+V\+Codec\+Internal}} is allocated. 

Definition at line 2540 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a9cc735be128cb62ff4cb594d3e3bdb92}\label{struct_a_v_h_w_accel_a9cc735be128cb62ff4cb594d3e3bdb92}} 
\index{AVHWAccel@{AVHWAccel}!name@{name}}
\index{name@{name}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{name}{name}}
{\footnotesize\ttfamily const char$\ast$ A\+V\+H\+W\+Accel\+::name}

Name of the hardware accelerated codec. The name is globally unique among encoders and among decoders (but an encoder and a decoder can share the same name). 

Definition at line 2416 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_ac5692f044266af8c1c33b7ac549df338}\label{struct_a_v_h_w_accel_ac5692f044266af8c1c33b7ac549df338}} 
\index{AVHWAccel@{AVHWAccel}!pix\_fmt@{pix\_fmt}}
\index{pix\_fmt@{pix\_fmt}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{pix\_fmt}{pix\_fmt}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{pixfmt_8h_a9a8e335cf3be472042bc9f0cf80cd4c5}{A\+V\+Pixel\+Format}} A\+V\+H\+W\+Accel\+::pix\+\_\+fmt}

Supported pixel format.

Only hardware accelerated formats are supported here. 

Definition at line 2416 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a0094df5ea13d644ebcba1237d45055be}\label{struct_a_v_h_w_accel_a0094df5ea13d644ebcba1237d45055be}} 
\index{AVHWAccel@{AVHWAccel}!priv\_data\_size@{priv\_data\_size}}
\index{priv\_data\_size@{priv\_data\_size}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{priv\_data\_size}{priv\_data\_size}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}} A\+V\+H\+W\+Accel\+::priv\+\_\+data\+\_\+size}

Size of the private data to allocate in \mbox{\hyperlink{struct_a_v_codec_internal_a888a25d20e49fd9efc779a09e4a6cb05}{A\+V\+Codec\+Internal.\+hwaccel\+\_\+priv\+\_\+data}}. 

Definition at line 2554 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a40b92f781dbaaecc9c82f636b790629b}\label{struct_a_v_h_w_accel_a40b92f781dbaaecc9c82f636b790629b}} 
\index{AVHWAccel@{AVHWAccel}!start\_frame@{start\_frame}}
\index{start\_frame@{start\_frame}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{start\_frame}{start\_frame}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::start\+\_\+frame) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx, const \mbox{\hyperlink{audio__convert_8c_ae1affc9ca37cfb624959c866a73f83c2}{uint8\+\_\+t}} $\ast$buf, uint32\+\_\+t buf\+\_\+size)}

Called at the beginning of each frame or field picture.

Meaningful frame information (codec specific) is guaranteed to be parsed at this point. This function is mandatory.

Note that buf can be N\+U\+LL along with buf\+\_\+size set to 0. Otherwise, this means the whole frame is available at this point.


\begin{DoxyParams}{Parameters}
{\em avctx} & the codec context \\
\hline
{\em buf} & the frame data buffer base \\
\hline
{\em buf\+\_\+size} & the size of the frame in bytes \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
zero if successful, a negative value otherwise 
\end{DoxyReturn}


Definition at line 2472 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_af962ad3e15697454ba312d1254e5a423}\label{struct_a_v_h_w_accel_af962ad3e15697454ba312d1254e5a423}} 
\index{AVHWAccel@{AVHWAccel}!type@{type}}
\index{type@{type}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{type}{type}}
{\footnotesize\ttfamily enum \mbox{\hyperlink{group__lavu__misc_ga9a84bba4713dfced21a1a56163be1f48}{A\+V\+Media\+Type}} A\+V\+H\+W\+Accel\+::type}

Type of codec implemented by the hardware accelerator.

See A\+V\+M\+E\+D\+I\+A\+\_\+\+T\+Y\+P\+E\+\_\+xxx 

Definition at line 2416 of file avcodec.\+h.

\mbox{\Hypertarget{struct_a_v_h_w_accel_a19115ab5af7bf9e638889ffee0b4e232}\label{struct_a_v_h_w_accel_a19115ab5af7bf9e638889ffee0b4e232}} 
\index{AVHWAccel@{AVHWAccel}!uninit@{uninit}}
\index{uninit@{uninit}!AVHWAccel@{AVHWAccel}}
\doxysubsubsection{\texorpdfstring{uninit}{uninit}}
{\footnotesize\ttfamily \mbox{\hyperlink{ffmpeg__filter_8c_a61569f2965b7a369eb10b6d75d410d11}{int}}($\ast$ A\+V\+H\+W\+Accel\+::uninit) (\mbox{\hyperlink{struct_a_v_codec_context}{A\+V\+Codec\+Context}} $\ast$avctx)}

Uninitialize the hwaccel private data.

This will be called from \mbox{\hyperlink{doc_2examples_2qsvdec_8c_afe1023087c26d2d410c9cd7d491c8660}{get\+\_\+format()}} or \mbox{\hyperlink{group__lavc__core_gaf4daa92361efb3523ef5afeb0b54077f}{avcodec\+\_\+close()}}, after hwaccel and hwaccel\+\_\+context are already uninitialized. 

Definition at line 2548 of file avcodec.\+h.



The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
E\+:/github/ffmpeg/libavcodec/\mbox{\hyperlink{avcodec_8h}{avcodec.\+h}}\end{DoxyCompactItemize}
